# 15486번. 퇴사 2

"""
- 오늘부터 N+1일 째 되는 날 퇴사하기 위해 남은 N일 동안 최대한 많은 상담 진행
- 하루에 하나씩 서로 다른 사람의 상담을 잡아 놓음
- 상담을 완료하는데 걸리는 시간 $T_i$
- 상담을 했을 때 받을 수 있는 금액 $P_i$
- N일까지만 상담을 진행할 수 있고, N+1일에는 회사에 없음
- 퇴사 전에 할 수 있는 상담의 최대 이익을 구해야 함
---
- N : 퇴사까지 남은 일자, 상담을 할 수 있는 일자
- $T_i$ : 상담을 완료하는데 걸리는 시간
- $P_i$ : 상담을 했을 때 받을 수 있는 금액
---
- 1 ≤ N ≤ 1,500,000
- 1 ≤ T ≤ 50
- 1 ≤ P ≤ 1,000

0. 패턴 찾기
    - 이전에 푼 [백준 11722번. 가장 긴 감소하는 부분 수열](https://www.notion.so/11722-35f16526422d4b6f912e18cce9667bde?pvs=21) 과 비슷하게 접근할 수 있을듯!
    - 연산을 할 때,
        - 앞에서 뒤를 고려하는 방식은, 뒷 부분 연산이 미리 되어있지 않아서 최종 값으로 연산할 수 없음
        - 원소 하나씩 접근하면서, 그 앞에 있는 것들을 고려해서 연산
        → 하루씩 일정에 접근하고, 해당 일정에 상담을 한다면 그 앞에 ~~몇 개의 상담을 할 수 있는지 연산~~ 얼마의 돈을 벌 수 있는지 연산, 최댓값 갱신
        → 일자별로 가질 수 있는 앞 일자 고려 누적하여 연산, 최댓값 갱신
        → 최종적으로 가장 큰 값이 최대 이익
1. N 입력 값 받기
2. 이차원 배열 안에 일자별 T, P 입력 값 받기
3. 일자별 이익을 저장할 배열 생성(초기값은 0으로)
4. 이차원 배열 내 값이 하나씩 접근하는 반복문 실행(일자별 스케줄에 하나씩 접근)
    1. T 값, P 값 추출
    2. 현재 일자에서 상담을 마치는 날짜가 퇴사 전날인지 확인 → 상담 선택 여부 결정
    3. ~~앞에 있는 일정에 하나씩 접근하여 T값이 현재 확인 중인 일자보다 짧은지 확인~~
        1. **하나씩 다 접근하면, 양립할 수 없는 일정들이 누적되어 합산될 수 있음**
        2. **바로 앞에 것 하나만 확인해서, 앞 부분까지 고려해서 누적 연산된 값을 가져와 최대값 갱신해야 함**
            1. 전날까지 번 돈에 이번 상담을 하게되어서 추가로 벌게 된 돈을 합한 것과
            2. 기존 상담이 마치는 날까지 벌 수 있는 값을 비교하여
            3. 상담을 마치는 날짜에 벌 수 있는 최대값 갱신
5. 최종적으로 배열에 저장된 가장 큰 값 출력
"""

from sys import stdin
input = stdin.readline

def solution():
    N = int(input())

    money = [0] * (N+1)

    for i in range(1, N+1):
        T, P = map(int, input().split())
        # print(i)
        # print("T: ", T, ", P: ", P)
        # print("전 money:", money[i])
        money[i] = max(money[i], money[i-1])
        # print("후 money:", money[i])

        if i+T-1 <= N : # 당일까지 포함하여 일정이 되는 경우
            # 해당 상담을 통해 벌 수 있는 돈 추가
            # 바로 전날까지 벌 수 있는 돈에 이번 상담 돈 추가한 값과 기존 값 비교하여 최댓값 갱신
            # print("일정이 돼! i:", i," T:", T, " P:", P)
            # print("전 money", i+T-1, ": ", money[i+T-1])
            money[i+T-1] = max(money[i-1]+P, money[i+T-1])
            # print("후 money", i+T-1, ": ", money[i+T-1])

        # print("*****************")

    print(max(money))


if __name__ == "__main__":
    solution()