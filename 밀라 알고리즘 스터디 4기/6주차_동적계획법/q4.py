# 프로그래머스. 정수 삼각형

"""
- 삼각형의 꼭대기에서 바닥까지 이어지는 경로 중, **거쳐간 숫자 합이 가장 큰 경우 탐색**
- 아래 칸으로 이동할 때는 대각선 왼쪽, 오른쪽으로만 이동 가능
    → 이차원 배열 내, n번에서 이동하려면 다음 배열의 **n, n+1** 인덱스로만 이동 가능
    → 아래에서 위 방향으로 생각한다면 이전 배열의 **n-1, n** 인덱스에서만 이동 가능
---
- triangle : 삼각형 정보가 담긴 배열
---
- 1 ≤ len(triangle) ≤ 500

1. 패턴 찾기
    - 위에서 아래로 내려가면서 총합 연산
    - 최대값 30을 만드려면 7 - 3 - 8 - 7 - 5 선택
    - 7에서 8을 선택하는 것이 아닌 3을 선택해야 최종 최대값이 나오기 때문에 그리디로 풀이 불가
    - 한 칸 내려갈 때 마다 값을 케이스별로 연산해서 저장한 뒤 나올 수 있는 총합 중 최대값 반환 필요
    - 한 칸씩 내려가며 연산하는 방식
        - 맨 왼쪽에 있는 3, 8, 2, 4는 윗층의 맨 앞 값을 선택했을 때만 선택 가능
        - 맨 오른쪽에 있는 8, 0, 4, 5는 윗층의 맨 뒷 값을 선택했을 때만 선택 가능
        - 숫자로 둘러쌓인 1, 7, 4, 5, 2, 6은 윗층 값 중 큰 값을 선택한 후 내려올 수 있음(=이게 최대)
    - 반복문을 돌면서 만들 수 있는 경우의 수 연산
---
1. 삼각형 레벨 하나씩을 도는 반복문 실행
    - 맨 윗 레벨은 원소가 하나라 무조건 선택, 두 번째 레벨부터(인덱스 상으로는 1) 확인하면 됨
2. 내부에 레벨 내 원소를 하니씩 도는 반복문 실행
3. 맨 마지막 레벨에 누적 합이 저장될 수 있도록, **한 칸씩 내려가면서 해당 숫자에 이전 선택 값 더하기**
    1. 맨 왼쪽 끝이면, 윗층의 맨 앞 값 더하기
    2. 맨 오른쪽 끝이면, 윗층의 맨 뒷 값 더하기
    3. 가운데 값이면, 윗층의 양쪽 옆 값 중 더 큰 값 더하기
4. 맨 마지막 층에 누적 합 값이 연산되어있기 때문에, 그 중 max 값 반환
"""

def solution(triangle):

    # 맨 윗 층을 제외하고 한 층씩 반복문으로 접근
    for i in range(1, len(triangle)):
        for j in range(len(triangle[i])):
            # 왼쪽 끝 -> 윗 층 맨 앞 값 선택
            if j == 0:
                triangle[i][j] += triangle[i-1][0]
            
            # 오른쪽 끝 -> 윗 층 맨 끝 값 선택
            elif j == len(triangle[i])-1:
                triangle[i][j] += triangle[i-1][-1]

            # 가운데
            else:
                triangle[i][j] += max(triangle[i-1][j-1], triangle[i-1][j])
    
    # 맨 마지막 층에 누적된 총합 값 중 최대 리턴
    return max(triangle[-1])

if __name__ == "__main__":
    triangle = [[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]]
    print(solution(triangle))