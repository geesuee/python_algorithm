# 백준 2240번. 자두 나무

"""
- 자두 나무에서 자두가 떨어질 때를 기다려서 자두를 받아 먹음
- 바닥에 떨어지기 전에, 자두가 허공에 있을 때 잡아야 함
- **매 초마다,** 두 개의 자두 나무 중 하나의 나무에서 열매가 떨어짐
- 만약 열매가 떨어지는 순간, **사람이 자두 나무 아래 서 있으면 그 열매를 받아 먹을 수 있음**
- 두 개의 나무는 멀리 떨어져있지 않기 때문에 하나의 나무 아래 서 있다가 **다른 나무 아래로 1초보다 짧은 시간에 움직일 수 있지만, 체력이 좋지 못해 많이 움직일 수는 없음**
- **자두는 T초 동안 떨어지고, 사람은 최대 W번만 움직이고 싶음**
- 매 초마다 어느 나무에서 자두가 떨어질지에 대한 정보가 주어졌을 때, **자두가 받을 수 있는 자두 개수**를 구하는 프로그램을 작성
- **맨 처음에 사람은 1번 자두 나무 아래 위치함**
**→ 1번 움직였을 때, 2번 움직였을 때, … N번 움직였을 때 각각의 최적을 모아서 전체의 최적을 구해야 함 = DP**
- **dp[초][이동 횟수] = [초] 까지 [이동 횟수] 만큼 이동했을 때 얻을 수 있는 최대 자두 수**
- dp[1][0] = 1초 까지 0번 이동했기 때문에 1번 나무 아래 = 1초에 1번 자두 나무에서 자두가 떨어졌다면 1 = jadu[1] % 2 (2로 나눈 나머지이기 때문에 1이면 1, 2면 0)
- dp[1][1] = 1초 까지 1번 이동했기 때문에 2번 나무 아래 = 1초에 2번 자두 나무에서 자두가 떨어졌다면 1 = jadu[1] // 2 (2로 나눈 몫이기 때문에 1이면 0, 2면 1)
- **dp[t][w] = t-1초 까지 w 이하로 움직였을 때 최대 자두 수 + t초에 한번 더 이동해서 최대 이동 횟수 채웠을 때 얻는 자두 수**
---
- T : 자두가 떨어지는 총 시간(초)
- W : 사람이 움직일 수 있는 최대 횟수
---
- 1 ≤ T ≤ 1,000
- 1 ≤ W ≤ 30
---
- 시간 제한 2 초
- 메모리 제한 128 MB

1. 자두가 떨어지는 초 T, 이동할 수 있는 횟수 W 입력 받기
2. T 줄로 입력되는 자두 떨어지는 나무 번호 입력 받기
3. DP 값 저장할 이차원 배열 생성
4. 1초 일 때, dp[1][0] 이랑 dp[1][1] 값 넣어주기
5. t는 2에서부터 T까지, w는 0에서부터 w까지 이중 반복문 실행
    1. 현재 초, 현재 위치에서 얻을 수 있는 자두 수 연산
        - 처음 위치는 1번 나무 아래니까 w가 홀수면 현 위치 2번 나무, w가 짝수면 현 위치 1번 나무
        - 1번 나무에서 받는 자두 수 = jadu[t] % 2
        - 2번 나무에서 받는 자두 수 = jadu[t] // 2
    2. 이전 초까지 얻을 수 있는 최대 자두 수에 현재 얻을 수 있는 자두 수 더해서 dp[t][w] 연산
6. 이차원 배열 내 최대 값 출력
"""

from sys import stdin
input = stdin.readline

def solution():
    T, W = map(int, input().split())
    jadu = [0] + [int(input()) for x in range(T)]

    dp = [[0] * (W+1) for _ in range(T+1)]
    
    dp[1][0] = jadu[1] % 2      # 1초에 1번 나무애 있을 때 받을 수 있는 자두 수
    dp[1][1] = jadu[1] // 2     # 1초에 2번 나무에 있을 때 밷을 수 있는 자두 수

    for t in range(2, T+1):
        for w in range(W+1):
            if w % 2 == 0:      # 짝수만큼 이동했으면, 1번 나무
                jadu_now = jadu[t] % 2
            else:               # 홀수만큼 이동했으면, 2번 나무
                jadu_now = jadu[t] // 2
            
            dp[t][w] = max(dp[t-1][0:w+1]) + jadu_now
    
    print(max(dp[-1]))

if __name__ == "__main__":
    solution()