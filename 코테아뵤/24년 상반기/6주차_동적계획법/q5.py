# 백준 11722번. 가장 긴 감소하는 부분 수열

"""
- 수열 A가 주어졌을 때, 가장 긴 감소하는 부분 수열을 구해야 함
- 수열 A = {10, 30, 10, 20, 20, 10}
- 가장 긴 감소하는 부분 수열은 A = {**30**, **20**, **10**}, 길이는 3
---
- N : 수열의 크기
- $A_i$ : 수열을 이루고 있는 원소
---
- 1 ≤ N ≤ 1,000
- 1 ≤ $A_i$ ≤ 1,000

1. 패턴 찾기
    - A = {10, 30, 10, 20, 20, 10}
    - 가장 긴 부분 수열을 만드려면,
        - 선택한 값을 부분 수열의 맨 앞으로 보는 방식
        : 큰 수를 기준으로 뒤에 작은 수가 차례로 얼마나 있는지 확인
        - 선택한 값을 부분 수열의 맨 뒤로 보는 방식
        : 뒤에 있는 작은 수를 기준으로 앞에 큰 수가 차례로 얼마나 있는지 확인
    - 10을 포함하면
        - 앞에 수가 없음, 부분 수열 길이 1
    - 30을 포함하면
        - 앞에 더 큰 수가 없음, 부분 수열 길이 1
    - 10을 포함하면
        - 앞에 더 큰 수가 1개(30) 있음, 부분 수열 길이 2
    - 20을 포함하면
        - 앞에 더 큰 수가 1개(30) 있음, 부분 수열 길이 2
    - 20을 포함하면
        - 앞에 더 큰 수가 1개(30)있음, 부분 수열 길이 2
    - 10을 포함하면
        - 앞에 더 큰 수가 2개(30,20)있음, 부분 수열 길이 2
    → 원소 하나씩 접근하여 해당 원소를 끝 원소로 했을 때, 만들 수 있는 최대 부분 수열 길이 연산
    → 지나온 원소에 다시 접근하면서 더 큰 값이 있는지 확인하여 최대 부분 수열 길이 갱신
---
1. 수열 A의 크기 N 입력 받기
2. 수열 A의 원소 순서대로 입력 받아 리스트 만들기
3. 원소별로 해당 원소를 맨 끝으로 했을 때 만들 수 있는 최대 부분 수열 길이를 저장할 배열 생성
    1. 길이는 원소 길이와 동일
    2. 초기값은 1 (부분 수열의 최소 길이는 1)
4. 반복문으로 A의 원소 하나씩 접근
    1. 이중 반복문으로 해당 원소 앞에 있는 원소에 하나씩 접근
    2. 앞에 현재 원소보다 더 큰 값이 있는지 확인
        1. 있다면, 감소하는 부분 수열을 만들 수 있으니 길이 연장
5. 최종적으로 배열에 저장된 가장 큰 값 출력
"""

from sys import stdin
input = stdin.readline

# 내 풀이
def solution():
    N = int(input())
    A = list(map(int, input().split()))
    
    subset = [1] * N
    
    for i in range(N): # 원소 하나씩 접근
        for j in range(i): # 현재 원소 앞 원소 접근
            if A[j] > A[i]: # 앞 원소가 현재 원소보다 크면
		        # 만들 수 있는 최대 부분 수열 길이 갱신
		        # 현재 원소 포함 만들 수 있는 부분 수열 길이 vs 앞 원소 포함 길이 + 1(=현재 원소까지)
                subset[i] = max(subset[i], subset[j]+1)
    
    print(max(subset))

# 다른 사람 풀이
"""
A = {10, 30, 10, 50, 3, 3} 
→ 가장 긴 감소하는 부분 수열은 {30, 10, 3} 인데
아래 풀이에서는 stack 값이 {50, 10, 3}
답의 길이는 동일하지만 구성이 다름
"""
def sol():
    N = int(input())
    nums = [*map(int,input().split())]
    stack = [nums[0]]

    for i in nums[1:]:
        if stack[-1] > i:
            stack.append(i)
        else:
            for j,v in enumerate(stack):
                if i >= v:
                    stack[j] = i
                    break
    # print(stack)
    print(len(stack))

if __name__ == "__main__":
    # solution()
    sol()